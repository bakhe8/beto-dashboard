import{_ as o,c as t,o as a,aj as n}from"./chunks/framework.D3ayZeS-.js";const h=JSON.parse('{"title":"Development Morphology","description":"","frontmatter":{"title":"Development Morphology"},"headers":[],"relativePath":"architecture/morphology.md","filePath":"architecture/morphology.md"}'),l={name:"architecture/morphology.md"};function s(i,e,r,c,p,d){return a(),t("div",null,[...e[0]||(e[0]=[n(`<h1 id="development-morphology" tabindex="-1">Development Morphology <a class="header-anchor" href="#development-morphology" aria-label="Permalink to &quot;Development Morphology&quot;">​</a></h1><p>This guide standardizes the shape, flow, and semantics of how we build within BetoDashboard.</p><h2 id="component-structure-morphology" tabindex="-1">Component Structure Morphology <a class="header-anchor" href="#component-structure-morphology" aria-label="Permalink to &quot;Component Structure Morphology&quot;">​</a></h2><ul><li>Naming: PascalCase component names; files at <code>packages/core/src/components/Name.ts</code>.</li><li>Entry: <code>define(&#39;Name&#39;, Component)</code> via DCE; export default for direct imports.</li><li>Form: Prefer the <code>ComponentMorph.create()</code> template for simple components.</li><li>HTML: Generate markup via <code>render(ctx) =&gt; string</code> and inject with <code>setHTML()</code>.</li><li>Events: Use delegated selectors in <code>events</code> map.</li><li>Slots: Consume <code>ctx.slots</code> for composition; prefer semantic regions.</li></ul><p>Outline</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Name.ts</span></span>
<span class="line"><span>  └─ ComponentMorph.create(&#39;Name&#39;, {</span></span>
<span class="line"><span>       stateKeys: [&#39;theme&#39;|&#39;dir&#39;|...],</span></span>
<span class="line"><span>       render({ root, props, slots, state }) =&gt; string,</span></span>
<span class="line"><span>       events: { selector: (ev, target, ctx) =&gt; void },</span></span>
<span class="line"><span>       afterRender?: (ctx) =&gt; void</span></span>
<span class="line"><span>     })</span></span></code></pre></div><h2 id="lifecycle-flow-morphology" tabindex="-1">Lifecycle Flow Morphology <a class="header-anchor" href="#lifecycle-flow-morphology" aria-label="Permalink to &quot;Lifecycle Flow Morphology&quot;">​</a></h2><p>Sequence: create → (subscribe) → render → events/effects → update → teardown.</p><ul><li>Creation: Initialize ctx (root, props, slots, state snapshot).</li><li>Subscription: For <code>stateKeys</code>, re-render on change.</li><li>Render: Produce and set sanitized HTML.</li><li>Events: Delegated handlers are attached once via BaseComponent.</li><li>Teardown: Unsubscribe and dispose effects.</li></ul><h2 id="state-morphology" tabindex="-1">State Morphology <a class="header-anchor" href="#state-morphology" aria-label="Permalink to &quot;State Morphology&quot;">​</a></h2><ul><li>Single key access: <code>createSlice(&#39;key&#39;)</code> for get/set/on.</li><li>Derived values: <code>createDerived([...keys], compute)</code> for stable compositions.</li><li>Async flows: <code>createAsyncAction(fn)</code> for predictable status transitions.</li></ul><h2 id="development-process-morphology" tabindex="-1">Development Process Morphology <a class="header-anchor" href="#development-process-morphology" aria-label="Permalink to &quot;Development Process Morphology&quot;">​</a></h2><ul><li>Scaffolding: <code>npm run morph:component -- --name=UserList</code> generates a component skeleton.</li><li>Tests: Prefer unit tests per primitive; E2E for composition and a11y.</li><li>Docs: Add a short usage snippet under <code>docs/components/</code> when stabilizing.</li></ul><h2 id="morphological-patterns-for-scalability" tabindex="-1">Morphological Patterns for Scalability <a class="header-anchor" href="#morphological-patterns-for-scalability" aria-label="Permalink to &quot;Morphological Patterns for Scalability&quot;">​</a></h2><ul><li>Reusable UI templates: Notice, Modal, Table, FormGroup (planned) via ComponentMorph.</li><li>Store key conventions: kebab-case in HTML <code>data-props</code>, camelCase in TypeScript, keys declared in <code>State</code>.</li><li>Unified config (planned): <code>beto.config.ts</code> to drive tokens, CSP toggles, and component defaults.</li></ul><h2 id="rules-adopt-as-defaults" tabindex="-1">Rules (Adopt as Defaults) <a class="header-anchor" href="#rules-adopt-as-defaults" aria-label="Permalink to &quot;Rules (Adopt as Defaults)&quot;">​</a></h2><ul><li>Prefer <code>ComponentMorph.create()</code> for non-trivial DOM components.</li><li>Always delegate events through <code>BaseComponent.on()</code> or <code>events</code> map.</li><li>Avoid raw <code>innerHTML</code>; use <code>setHTML()</code>.</li><li>Persist only whitelisted state keys.</li><li>Add unit tests when introducing a new primitive.</li></ul><h2 id="prototype-implementations" tabindex="-1">Prototype Implementations <a class="header-anchor" href="#prototype-implementations" aria-label="Permalink to &quot;Prototype Implementations&quot;">​</a></h2><ul><li>ComponentMorph factory: <code>@betodashboard/core/js/morph</code>.</li><li>Example component using Morph: <code>Notice</code> (dismissible message).</li><li>CLI generator: <code>npm run morph:component -- --name=MyComponent</code>.</li></ul>`,19)])])}const u=o(l,[["render",s]]);export{h as __pageData,u as default};
